## backend /src/lib 重构与迁移修改计划

> 目标：把通用基础设施（下载、日志、模糊搜索、通用工具等）从业务层 `/api`、`/utils`、`/types` 拆出来，集中进 `/src/lib`，形成可复用、可测试、依赖关系清晰的库层。

---

## 目录规划（目标结构）

- **目录结构目标**

  ```text
  backend/src/lib/
    download/
      client.ts          // HTTP 客户端封装（axios 等）
      file-cache.ts      // 文件缓存 + ETag + TTL
      memory-cache.ts    // 进程内缓存（可选，带 TTL/容量控制）
      service.ts         // 对外的 downloadBinary / downloadJson / downloadWithRetry 等
    logger/
      index.ts           // 日志接口与默认实现
    fuzzy-search/
      index.ts           // 对外入口：fuzzySearch / match / checkRelationList 等
      parser.ts          // 关键字解析、Lv/比较符等
      matcher.ts         // 与目标对象匹配逻辑
      relation.ts        // `<10`、`>5`、`8-10` 等关系判断
    utils/
      path-utils.ts      // cache 目录、路径拼接、非法字符处理
      url-utils.ts       // URL 解析、扩展名/文件名处理
      number.ts          // formatNumber 等数字工具
      collections.ts     // Stack 等通用数据结构
    config/
      runtime-loader.ts  // 统一从 `config/runtime.ts` 读取需要的运行时配置
    clients/
      BestdoriClient.ts  // 第三方服务客户端
  ```

---

## 阶段一：建立 /src/lib 基础骨架（不改任何业务逻辑）✅

- **Step 1.1：创建基础目录与空文件** ✅
  - 创建目录：
    - `backend/src/lib/download/`
    - `backend/src/lib/logger/`
    - `backend/src/lib/fuzzy-search/`
    - `backend/src/lib/utils/`
    - `backend/src/lib/config/`
    - `backend/src/lib/clients/`
  - 在每个目录先放一个最小的 `index.ts` 或占位文件（例如只导出空对象/简单函数），确保编译通过。

- **Step 1.2：新增 config 统一入口** ✅
  - 新建 `backend/src/lib/config/runtime-loader.ts`：
    - 对外提供统一方法：`getRuntimeConfig()`，内部从 `src/config/runtime.ts` 读取。
    - 暴露最常用配置：`cacheRootPath`、`assetsRootPath`、`fuzzySearchPath` 等（先保持只读，无缓存逻辑变更）。

> 阶段一目标：只「新增」代码，不修改现有 import，保证行为完全不变，只是先把骨架搭好。

---

## 阶段二：下载模块迁移到 /lib/download ✅

- **Step 2.1：抽离 URL/路径 工具** ✅
  - 源文件：
    - `backend/src/api/utils.ts`
  - 新建：
    - `backend/src/lib/utils/path-utils.ts`：放 `sanitizeDirectoryName` + cache 路径相关逻辑。
    - `backend/src/lib/utils/url-utils.ts`：放 `getFileNameFromUrl`、URL 解析相关逻辑。
  - 修改方式：
    - 先在新文件中「复制」实现，并从 `lib` 内使用（后续逐步把 `api/utils.ts` 改为简单封装或废弃）。
    - 暂时保留 `api/utils.ts`，等所有引用都切到 `lib` 后再移除。

- **Step 2.2：封装 HTTP 客户端** ✅
  - 源文件：
    - `backend/src/api/downloader.ts`（直接用 axios）
  - 新建：
    - `backend/src/lib/download/client.ts`：提供基础方法：
      - `requestBinary(url, options)`：返回 Buffer。
      - 支持配置超时、headers（包括 ETag）、错误包装。
  - 第一版实现可以基本复制 `downloader.ts` 中 axios 调用逻辑，注意：
    - 使用 `async/await` + 明确的错误类型/日志。

- **Step 2.3：文件缓存和 ETag 抽象** ✅
  - 源文件：
    - `backend/src/api/downloader.ts` 中关于：
      - cache 文件路径和 `.etag` 文件处理
      - `cacheTime` 判断 / 304 处理逻辑
  - 新建：
    - `backend/src/lib/download/file-cache.ts`：
      - 对外函数：
        - `readCacheIfValid(path, etag?, ttlMs?)`
        - `writeCache(path, buffer, etag?)`
      - 封装所有 fs 读写与时间比较、304 情况下读取 cache 的逻辑。
    - 优先保持同步/异步模式与当前实现兼容（可以先沿用 `fs.*Sync`，后续再统一异步化）。

- **Step 2.4：download service 重写成 /lib API** ✅
  - 源文件：
    - `backend/src/api/downloader.ts`
    - `backend/src/api/downloadFile.ts`
    - `backend/src/api/downloadFileCache.ts`
  - 新建：
    - `backend/src/lib/download/service.ts`：
      - 对外提供：
        - `downloadBinary(url: string, options: DownloadOptions): Promise<Buffer>`
        - `downloadJson<T>(url: string, options: DownloadOptions): Promise<T>`
        - `downloadWithRetry(url, options): Promise<Buffer>`
      - 内部使用：
        - `client.ts` 处理 HTTP
        - `file-cache.ts` 处理缓存 & ETag
        - 可选：`memory-cache.ts` 做进程内缓存（替代 `downloadFileCache.ts` 里那段 Map）。
  - 迁移策略：
    - 第一阶段：`service.ts` 中直接「复制」现有逻辑，保持语义一致（包含：
      - errUrl 记忆错误 URL
      - PNG/SVG 出错返回默认图片 buffer
      - 3 秒重试 等）。
    - `downloadFile.ts` / `downloadFileCache.ts` 逐步改成简单的 wrapper，委托给 `lib/download/service`。
    - 最终目标：业务层只 import `lib/download/service`，不再直接 import `api/downloader.ts` 等。

---

## 阶段三：logger 模块迁移到 /lib/logger

- **Step 3.1：抽出 logger 接口**
  - 源文件：
    - `backend/src/utils/logger.ts`
  - 新建：
    - `backend/src/lib/logger/index.ts`：
      - 定义接口：
        - `export interface Logger { log(type: string, message: any): void }`
      - 提供默认实现：
        - `export const logger: Logger = { log(type, message) { ... } }`
  - 迁移方式：
    - 第一步：在 `lib/logger` 中复制原实现，保持行为一致。
    - 第二步：逐个文件把 `import { logger } from '../utils/logger'` 替换为 `import { logger } from '../lib/logger'`（这一步可以分 PR/分 commit 做）。
    - 第三步：确认无引用后，删除 `src/utils/logger.ts` 或改为 re-export。

- **Step 3.2：与下载/模糊搜索整合**
  - 将 `fuzzySearch.ts`、下载相关模块中用到的 logger 替换为 `lib/logger`。

---

## 阶段四：模糊搜索迁移到 /lib/fuzzy-search ✅

- **Step 4.1：拆分 fuzzySearch 逻辑** ✅
  - 源文件：
    - `backend/src/utils/fuzzySearch.ts`
  - 新建：
    - `backend/src/lib/fuzzy-search/parser.ts`：
      - 解析 keyword，`extractLvNumber`、`isInteger` 等放这里。
    - `backend/src/lib/fuzzy-search/matcher.ts`：
      - `fuzzySearch`、`match` 相关的匹配逻辑。
    - `backend/src/lib/fuzzy-search/relation.ts`：
      - `checkRelationList` 以及 relation string 相关的校验。
    - `backend/src/lib/fuzzy-search/index.ts`：
      - 统一对外导出：`fuzzySearch`、`match`、`checkRelationList`、类型定义等。
  - 配置加载：
    - 使用 `lib/config/runtime-loader.ts` 提供的路径/配置读取 fuzzySearch 配置文件路径，而不是各处自己读取。

- **Step 4.2：替换业务引用** ✅
  - 后端中所有使用 fuzzySearch 的地方，改为从 `lib/fuzzy-search` 引用。
  - 已替换：CardService、CharacterService、EventService、SongService
  - 确认行为与老版完全一致后，删除 `src/utils/fuzzySearch.ts` 或改为简单 re-export。

---

## 阶段五：通用 utils & types 工具迁移 ✅

- **Step 5.1：从 types/utils.ts 抽出纯工具** ✅
  - 源文件：
    - `backend/src/types/utils.ts`
  - 新建：
    - `backend/src/lib/utils/number.ts`：`formatNumber` 等纯数字处理。
    - `backend/src/lib/utils/collections.ts`：`Stack` 等通用数据结构。
  - 调整：
    - 类型定义仍保留在 `src/types` 中，尽量保证 `/types` 只存放类型定义和纯函数（无 IO）。

- **Step 5.2：API utils 整合到 lib/utils** ✅
  - 将 `api/utils.ts` 中与 URL、文件名、路径相关的函数，逐步迁移/替换为 `lib/utils` 下的实现。
  - `api/utils.ts` 和 `types/utils.ts` 已改为 re-export，保持向后兼容
  - 最终状态：
    - `api/utils.ts` 只作为「业务层 helper」（如果还有需要），不再承担通用工具角色。

---

## 阶段六：第三方客户端迁移到 /lib/clients ✅

- **Step 6.1：BestdoriClient 移动** ✅
  - 源文件：
    - `backend/src/api/BestdoriClient.ts`
  - 新建：
    - `backend/src/lib/clients/BestdoriClient.ts`
  - 逻辑：
    - 不改变其对外接口签名，先纯粹移动 + 调整 import（如 logger、download 等从 `lib` 引用）。

- **Step 6.2：统一「外部服务客户端」规范** ✅
  - 后续若有其他外部服务访问，全部放到 `lib/clients` 目录。
  - BestdoriClient 已迁移，所有服务文件引用已更新

---

## 阶段七：清理与文档同步 ✅

- **Step 7.1：删除/瘦身旧文件** ✅
  - 已彻底删除以下旧文件：
    - ✅ `backend/src/api/BestdoriClient.ts` - 已迁移到 `lib/clients/BestdoriClient.ts`
    - ✅ `backend/src/api/downloader.ts` - 已迁移到 `lib/download/service.ts`
    - ✅ `backend/src/api/downloadFile.ts` - 已迁移到 `lib/download/service.ts`
    - ✅ `backend/src/api/downloadFileCache.ts` - 已迁移到 `lib/download/service.ts`
    - ✅ `backend/src/api/getApi.ts` - 功能已整合到 `lib/clients/BestdoriClient.ts`
    - ✅ `backend/src/api/utils.ts` - 已迁移到 `lib/utils/path-utils.ts` 和 `lib/utils/url-utils.ts`
    - ✅ `backend/src/utils/logger.ts` - 已迁移到 `lib/logger.ts`
    - ✅ `backend/src/utils/fuzzySearch.ts` - 已迁移到 `lib/fuzzy-search/`
    - ✅ `backend/src/types/utils.ts` - 已迁移到 `lib/utils/number.ts` 和 `lib/utils/collections.ts`
  - 所有业务代码引用已更新，编译通过

- **Step 7.2：更新文档** ✅
  - ✅ 已更新 `backend/README.md`：
    - 更新项目结构说明
    - 添加 `/src/lib` 的职责说明
    - 添加使用示例（下载模块、模糊搜索、日志、外部客户端）
  - ✅ 本文件（修改计划.md）已更新所有阶段完成状态

---

## 执行顺序建议（简版 checklist）

1. 创建 `src/lib` 目录和各子目录 + config/runtime-loader 骨架（阶段一）。
2. 抽出 URL/路径 utils + HTTP client + file-cache，搭好 `lib/download` 基础（阶段二）。
3. 在不删旧代码的前提下，实现 `lib/download/service` 并让业务逐步切换 import。
4. 迁移 logger 到 `lib/logger`，替换全局使用（阶段三）。
5. 拆分并迁移 fuzzySearch 到 `lib/fuzzy-search`，替换引用（阶段四）。
6. 迁移 types/utils 和 api/utils 中的通用函数到 `lib/utils`（阶段五）。
7. 迁移 BestdoriClient 等外部客户端到 `lib/clients`（阶段六）。
8. 最后统一清理旧文件、更新 README 与设计/迁移文档（阶段七）。

> 之后每做完一个阶段，可以在本文件对应章节打勾或追加备注，方便追踪迁移进度。



